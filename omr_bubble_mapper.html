<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OMR Bubble Mapper</title>
  <style>
    body { font-family: sans-serif; padding: 20px; }
    canvas { border: 2px solid #222; cursor: crosshair; }
    #coords { white-space: pre; background: #f5f5f5; padding: 10px; }
    button { margin-top: 10px; margin-right: 10px; padding: 8px 16px; }
    .control-panel { 
      margin: 10px 0; 
      padding: 15px;
      background: #f8f8f8;
      border-radius: 5px;
    }
    .control-panel label { 
      margin-right: 15px; 
      font-weight: bold;
    }
    #circleRadius {
      width: 200px;
      vertical-align: middle;
    }
    #drawingMode {
      padding: 5px;
      margin-right: 20px;
    }
    .canvas-container {
      position: relative;
      display: inline-block;
    }
  </style>
</head>
<body>

  <h2>üéØ OMR Bubble Mapper Tool</h2>
  <input type="file" id="upload" accept="image/*" />
  <br /><br />
  
  <div class="control-panel">
    <label for="drawingMode">Drawing Mode:</label>
    <select id="drawingMode">
      <option value="point">Point</option>
      <option value="circle">Circle</option>
    </select>
    
    <label for="circleRadius">Circle Size:</label>
    <input type="range" id="circleRadius" min="1" max="50" value="15" />
    <span id="radiusValue">15</span>px
  </div>
  
  <div class="canvas-container">
    <canvas id="canvas"></canvas>
  </div>
  <br />
  <button onclick="downloadJSON()">üì• Download Coordinates</button>
  <button onclick="resetCanvas()">üóëÔ∏è Reset All</button>

  <h3>üß≠ Clicked Coordinates:</h3>
  <div id="coords">[]</div>

  <script>
    const upload = document.getElementById('upload');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const coordsDisplay = document.getElementById('coords');
    const drawingModeSelector = document.getElementById('drawingMode');
    const circleRadiusSlider = document.getElementById('circleRadius');
    const radiusValue = document.getElementById('radiusValue');
    let image = new Image();
    let coords = [];
    let lastPreviewX = 0;
    let lastPreviewY = 0;

    // Update radius display when slider changes
    circleRadiusSlider.addEventListener('input', () => {
      radiusValue.textContent = circleRadiusSlider.value;
      if (lastPreviewX && lastPreviewY) {
        redrawCanvas();
        drawPreview(lastPreviewX, lastPreviewY);
      }
    });

    // Handle mouse movement for preview
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      lastPreviewX = Math.round(e.clientX - rect.left);
      lastPreviewY = Math.round(e.clientY - rect.top);
      
      redrawCanvas();
      drawPreview(lastPreviewX, lastPreviewY);
    });

    canvas.addEventListener('mouseleave', () => {
      lastPreviewX = 0;
      lastPreviewY = 0;
      redrawCanvas();
    });

    function drawPreview(x, y) {
      const mode = drawingModeSelector.value;
      const radius = parseInt(circleRadiusSlider.value);

      ctx.beginPath();
      if (mode === 'point') {
        ctx.arc(x, y, 3, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
        ctx.fill();
        // Add crosshair for point mode
        ctx.beginPath();
        ctx.moveTo(x - 10, y);
        ctx.lineTo(x + 10, y);
        ctx.moveTo(x, y - 10);
        ctx.lineTo(x, y + 10);
        ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
        ctx.lineWidth = 1;
        ctx.stroke();
      } else {
        // Draw preview circle
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
        ctx.lineWidth = 2;
        ctx.stroke();
        // Add center point
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, Math.PI * 2);
        ctx.fillStyle = "rgba(255, 0, 0, 0.5)";
        ctx.fill();
      }
    }

    upload.addEventListener('change', (e) => {
      const file = e.target.files[0];
      const reader = new FileReader();
      reader.onload = function (event) {
        image.onload = () => {
          canvas.width = image.width;
          canvas.height = image.height;
          ctx.drawImage(image, 0, 0);
        };
        image.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = Math.round(e.clientX - rect.left);
      const y = Math.round(e.clientY - rect.top);
      const radius = parseInt(circleRadiusSlider.value);
      const mode = drawingModeSelector.value;
      
      coords.push({
        x: x,
        y: y,
        radius: radius,
        mode: mode
      });

      redrawCanvas();
      drawPreview(x, y);
      coordsDisplay.textContent = JSON.stringify(coords, null, 2);
    });

    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (image.src) {
        ctx.drawImage(image, 0, 0);
      }
      
      // Draw all markers
      for (const coord of coords) {
        ctx.beginPath();
        if (coord.mode === 'point' || !coord.mode) {
          // Draw a point with crosshair
          ctx.arc(coord.x, coord.y, 3, 0, Math.PI * 2);
          ctx.fillStyle = "red";
          ctx.fill();
          // Add permanent crosshair for points
          ctx.beginPath();
          ctx.moveTo(coord.x - 5, coord.y);
          ctx.lineTo(coord.x + 5, coord.y);
          ctx.moveTo(coord.x, coord.y - 5);
          ctx.lineTo(coord.x, coord.y + 5);
          ctx.strokeStyle = "red";
          ctx.lineWidth = 1;
          ctx.stroke();
        } else if (coord.mode === 'circle') {
          // Draw circle with center point
          ctx.arc(coord.x, coord.y, coord.radius, 0, Math.PI * 2);
          ctx.strokeStyle = "red";
          ctx.lineWidth = 2;
          ctx.stroke();
          // Add center point
          ctx.beginPath();
          ctx.arc(coord.x, coord.y, 2, 0, Math.PI * 2);
          ctx.fillStyle = "red";
          ctx.fill();
        }
      }
    }

    function downloadJSON() {
      const blob = new Blob([JSON.stringify(coords, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const link = document.createElement("a");
      link.download = "bubble_map.json";
      link.href = url;
      link.click();
    }

    function resetCanvas() {
      coords = [];
      coordsDisplay.textContent = JSON.stringify(coords, null, 2);
      redrawCanvas();
    }
  </script>

</body>
</html>
